# 符号表

## 符号表的作用

在编译过程中，编译程序需要反复不断地收集和查证出现在源程序中各种名字的属性和特征。这些信息通常记录在一张或几张符号表里。符号表的每一项都包含两部分内容：符号的名称和有关信息/属性。这些信息将会用于语义检查、中间代码、目标代码生成等各阶段。

从语法分析开始，编译程序每扫描出一个单词，就会到符号表中检查是否存在。如果不存在的话就会填入符号表中。它的其他相关信息将会在各阶段的分析过程中陆续填入。在不同的阶段，符号表使用的侧重点也有所不同：语义分析中，符号表主要用于语义检查；目标代码生成中，符号表一般是用来分配变量内存空间的依据；对于多遍扫描程序来说，每次扫描的符号表也往往有所不同。

另外，虽然原则上符号表仅需要一张，但是实际生产中仍然会编制诸多针对不同类型的符号表，这样处理起来更加方便。

## 对符号表的操作

在编译期间，对符号表的操作大致分为五类：

1. 对给定字符串，查询是否是表中的项
2. 往表中加入一个新的项
3. 访问给定名称的某项的信息
4. 更新给定名称的某项的信息
5. 删除一个给定名称的项

## 符号表的组织

符号表中的每一项包含两栏，分别是名称栏和属性栏。其中属性栏中又分为很多子栏，用于记录各种不同的属性；名称栏又被称为主栏，其内容是查找符号表的关键字。

组织符号表最简单的方式是让每一栏所占用的存储单元的长度固定，当然这已经是C语言遗留下来的手动分配内存的古老特性。这种方式便于组织、填写、查找相关项目。但是如果不对标识符的长度加以限制的话，这种方式很容易就会造成大量内存的浪费。

所以一种间接安排名称栏和属性栏的方法，第一是在名称栏存放指针和名称长度指向另一块不定长空间；第二是将属性栏中共有属性直接登记在地址栏中，其他属性也通过指针转移到别的地方。另外，针对数组标识符，由于结构复杂，全部集中的话处理会很不方便。所以一般采用专门开辟内情向量表的方式，将数组的有关信息全部存入表中。这样对于一些特殊的名称，都可以采用内情向量表的方式保存信息。

## 符号表的检索

### 线性表

顾名思义，就是简单的链表。但是由于一般来讲后定义的标识符更容易被尽快使用，所以搜索的失火一般从线性表的结尾开始搜索。

另外还可以通过自动调整项目在线性表内的位置来达到优化的目的。例如将最后调用的标识符放到线性表的开头，上一个调用的标识符放到线性表的第二个位置，新加入的标识符也插入到线性表的第一个位置。这种线性表被称为自适应线性表。

### 二叉表

将表项按照名称的某种函数值进行排列，并且按照对折方式查找。这样的线性符号表就进化成二叉符号表。这样查找时间就从O(n)下降到O(log~2~(n))级别。但是这种性能增加对于编译程序来说并没有用，甚至性能上还不如线性表，因为符号表是边填入边检索，如果每填进一个新项都要经过重新整理数组的操作的话，浪费的时间更多。

一种变通的办法是用平衡树来组织符号表，让每个项都成为平衡树上的结点，这样插入新项的时候就不用移动一维数组中大量项目，仅仅平衡一小部分结点就可以。

这种方法的查询速度略低于直接取数组间接地址，并且数据结构和指针也会占用很多空间。

### 间接杂凑表

如何保证符号表同时满足高效检索与快速插入，同时在工程实现的时候还要尽量简洁不啰嗦，这就需要杂凑技术。

杂凑技术非常接近HashMap，但是在数据结构上有以下几个区别：

1. 杂凑表是由两个部分组成的，尽管在Java这样数据结构完善的语言中可以直接表述成以HashMap的形式，但是符号表本身的链表结构是不能丢弃的
2. 因为Hash函数存在的冲突问题，所以杂凑表对于冲突，会采取链表法来避免冲突，这就需要在符号表中新加一栏link，用于存放Hash值相同的项目的地址。这样在搜索的时候就可以按照link依次搜索到所有hash值相同的项目

间接杂凑表的形式如下：![img](assets/1565862076346.png)

但是实际上，间接杂凑表的这种数据结构和Java8以前的HashMap并没有本质区别，并且在某些方面还稍显啰嗦。所以如果用Java开发的话可以放心大胆的用HashMap作为符号表的数据结构。

## 符号表的作用域



## 符号表的内容

