# 语义分析

## 语义分析的任务

在一个句子通过语法分析，确定语法合法之后，编译程序就需要进行静态语义检查，并将句子翻译为中间语言；或者翻译成对应的动作。

### 静态语义检查

静态语义检查通常包括以下操作：

1. 类型检查：如果在语句的执行过程中会出现不兼容的操作数，比如A类型到B类型没有直接的一步转换方式，但是却出现了比较/赋值的操作，编译程序应该报错并给出相应的错误信息。
2. 控制流检查：比如在Java中，finally块之前必须有try块、else之前必须有if、switch块中至少case或者default要有一个、break只能用在循环或者switch块中。SQL也有很多类似的限制，比如union。
3. 一致性检查：一些对象在每一段程序中只能被定义一次，比如说switch case语句中的匹配常量不能出现重复的情况。
4. 对象名称统计：编译程序会在语法分析的基础上提取出所有定义的对象名称并保存到符号表里，而后会统计变量的使用是否超出了定义范围、是否存在用另一种类型定义同名变量、是否存在未初始化就参与运行的变量等。

### 翻译

大部分情况下，编译程序并不会将源程序直接翻译成目标代码，而是会先将其翻译成一种介于源语言和目标语言之间的语言。这样做的好处有：①隔离源语言与目标语言之间的关系，使编译程序的逻辑更加简洁；②方便进行代码优化；③修改编译程序更加容易。

## 中间语言

前几章介绍的抽象语法树，抽象语法树其实就是中间语言的一种，只不过看起来更不像一种语言。

常见的用来执行语义分析的中间语言有以下几种：

### 1.后缀式

后缀式一般也称逆波兰式，是波兰逻辑学家卢卡西维奇发明的一种表示表达式的方法。这种表示法将操作数写在前面，运算符写在后面。

一个表达式E的后缀式是E’，那么其后缀形式可以这样定义：

1. 如果E是直接操作数（常量或变量），则E’=E
2. 如果E是E~1~ op E~2~形式的表达式，且op是任意一个二元运算符，则E’=E~1~‘ E~2~‘ op
3. 如果E是(E~1~)形式的表达式，则E’=E~1~‘

这种表达式的好处在于不需要括号即可唯一确定所有操作数的运算顺序，同时后缀表示法也可以推广到其他语法形式中。

### 2.图表示法DAG

图表示法类似于抽象语法树，但是不同之处在于，抽象语法树的每个子树有且仅有一个父节点，图表示法允许有多个父节点。所以采用了有向无环图DAG作为数据结构。

DAG的优点，仍然是节省内存；以下是y=a+a\*(b-c)+(b-c)\*d的抽象语法树表示法和图表示法的可视化形式。

![img](assets/1565075784626.png)![img](assets/1565076017722.png)


### 3.三地址码

三地址代码是由下面的一般形式的语句构成的序列

​			$$x :=y\  op \ z$$

其中，x、y、z是变量、常数、函数或者编译时产生的临时变量，op代表运算符号，每个语句的右边只能有一个运算符。三地址码可以看成是抽象语法树的一种线性表示，例如y=a+a\*(b-c)+(b-c)\*d可以改写成以下一系列三地址码：

​			$$T_1=b-c \\T_2=a*T_1 \\T_3=T_1*d \\T_4=a+T_2 \\y=T_4+T_3$$

之所以称为三地址码，是因为这种编码方式需要三个地址用来存放操作数和结果；三地址码形式上类似汇编语言，也有各种标号以及控制流符号。

三地址码还有这么几个种类：

1. $$x :=y\  op \ z$$：其中op是二元运算符或者逻辑算符
2. $$x :=op \ y$$：其中op是一元算符
3. $$x :=y$$：赋值语句
4. goto L：无条件转移语句，将会转移到编号为L的语句
5. if a goto L：有条件转移语句，当a为假的时候执行下一条语句
6. param x 与 call p,n：输入参数x，调用过程p，设置过程p的参数数量n，返回一个参数y
7. 间接寻址，例如x[i]

## 类型检查

类型检查是静态语义分析的最重要的内容之一。大多数静态语义分析的工作都可以用语法制导翻译来解决，也有些工作可以合并到其他工作中，例如之前在将一个变量名称填入符号表的时候，就可以检查这个名称是否只定义过一次；还有算术表达式的翻译，就考虑了类型转换的问题。

其中部分实现要参考4.2中属性文法部分内容。

### 类型系统

为了设计类型检查器，就要首先考虑语法结构、表示类型的记号以及类型赋予给语法节点的规则。例如关于Java和C的运算规则：

“如果加法、减法、乘法和除法算术运算符的两个操作数都是整型的，则运算结果也是整型的”  
“一元运算符&的结果是一个指针，只想操作数提供的对象。结果的类型是指向操作数类型的指针”

这两段话说明每个表达式都有一个类型与之相关。这个问题是设计语言时就必须考虑好的。例如在Java当中除了基本类型和对象类型之外，数组、对象内部的方法、成员变量等也是结构化的数据类型。

如果类型检查在编译时进行，则称之为静态类型检查；如果在运行时进行，则称之为动态类型检查。理论上讲，只要目标代码中的信息足够，类型检查总是可以动态的进行。但是如果完全消除动态类型检查，保证编译后的程序不会出现类型错误的话，则说明这种语言的类型系统是良定义的，也可以称为强类型语言。

但是现实总是不那么尽如人意，有些检查只能动态的进行。比如说char类型，就不能保证赋值范围总是落在0~255之间（标准ASCII和扩展ASCII整体范围）。

### 类型检查器的规格说明

加入有一个语法P，P要求每个标识符在使用之前都必须预先声明。类型检查器可以检查简单类型、函数、指针、语句和数组，这个语法如下：

$$P \to D;E \\ D \to D;D|id:T \\ T \to char|int|array[num] of T| \uparrow T \\ E \to literal|num|id|E mod E|E\ [E]|E \uparrow $$

其中，非终结符P代表程序，非终结符D代表说明，非终结符E代表表达式。由以上文法可以生成如下语句：

```
key:int
key mod 1999
```

假定这种语言本身提供两种基本类型：int与char，还有缺省类型error与void。例如，由类型表达式array[256] of char(对应char[] c=new char[256])，可以导出类型表达式：

```
array(0 to 255, char)
```

这个表达式把构造类型的array指令用于相对内存地址0~255和类型char,如果在用一个前缀运算符↑设定一个指针类型，就可以自由的定义任何标识符的基本类型。

下面给出确定标识符类型的部分翻译模式：

1. $$P \to D;E$$
2. $$ D \to D;D$$
3. $$D \to id;T$$
4. $$T \to char$$
5. $$T \to int$$
6. $$T \to \uparrow T_1$$
7. $$T \to array[num]\ of\ T_1$$

在这个翻译模式中，产生式$$D \to id;T$$的语义动作形如addtype(id.entry, T.type)，把一个类型T.type存入id所代表的标识符的符号表里。这里的id.entry指向符号表中id的地址，非终结符的type是一个类型表达式。

对于语句的类型检查，很多语句本身是没有值的，所以我们默认赋予一个void类型；如果语义分析中，句子前后出现了类型不一致，就将error类型赋予这个句子。例如Java再大部分情况下都不允许在一个句子中只执行带基本类型返回值的函数，需要将这个函数的返回值赋值给一个新的变量，此时就应该执行检查。

以下列出两种语句类型检查的翻译模式：

1. S:id=E  {if id.type==E.type S.type=void else S.type=error}
2. S:if E then S~1~  {if E.type==boolean S.type=S~1~.type else S.type=error}

### 函数重载

函数(方法)重载(Overload)的定义：如果有两个方法的方法名相同，但参数不一致，哪么可以说一个方法是另一个方法的重载。 具体说明如下： 

- 函数名相同
- 函数的参数类型，参数个至少有一个不一样
- 函数的返回类型可以不相同，返回类型不做为区分标准
- 函数的修饰符可以不相同
- 函数可以在同一个类或者子类中被重载
- main方法也可以被重载 

在这种情况下，函数可以根据上下文传入参数的不同，执行不同的运算。

例如在Java中，Math类下面的很多函数都是通过检查操作数类型，选择不同的函数进行运算的。

另外，在大多数程序语言中，算术运算符都是重载运算符。这种重载可以通过检查操作数类型来解决，也可以通过属性文法计算出各个位置的操作数类型。

### 函数重写

函数重写在Java中的表现形式就是含有@Override标签的函数。重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。具体说明如下：

- 参数列表必须完全与被重写方法的相同。
- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类。
- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
- 父类的成员方法只能被它的子类重写。
- 声明为final/static的方法以及构造方法不能被重写。
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private/final的方法；子类和父类不在同一个包中，那么子类只能够重写父类的声明为public/protected的非final方法。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
- 如果不能继承一个方法，则不能重写这个方法，但是从Java11开始放松了这个限制。

这种情况下，函数可以根据声明作用域的不同，执行不同的运算。

### 多态函数

一般来说，函数只能用固定类型的参数，进行同一种操作。多态函数通过检查传递形参的类型，选择不同的操作，所以理论上还可以有多态操作符。

大部分语言的内部操作符，比如数组下标操作符、指针操作符等都具有多态性（Java的话可能是赋值操作符）。

Java可以用泛型、反射和可变长参数实现多态，例如如下的示例代码：

```java
public void PolymorphiDemo(Class<?> methodString, int range, String... parameters) {
    try {
        if(parameters.length!=4){}
            this.getClass().getMethod(methodString.getSimpleName(), int.class).invoke(this, range);
        } else {
        //先根据泛型类，由反射获取类型名称；然后用getMethod方法获取类中的待调用方法名称与参数列表，确定唯一方法；最后通过invoke传递参数并执行方法。
            this.getClass().getMethod(methodString.getSimpleName(), int.class, String.class).invoke(this, range, parameter[2]);
        }
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    }
}
```
